const classcode = require('./makecases').classcode
const classname = require('./makecases').classname

// turn all types that are 'array' in apib into scala List[MyType]
function fixArrayReferences(result, input, options) {
  const arraymap = arrays(input, options)
  for (const [tname, aname] of arraymap) {
    var re = new RegExp(tname,'g')
    result = result.replace(re, aname)
  }
  return result
}

//
// generator functions to create scala code
//

// create each case class
function* classes(input, options) {
  for (const content of input.content) {
    if (!content.content) throw new Error('bad input')
    if (content.element === 'category') {
      for (const item of content.content) {
        if (
          item.element === 'dataStructure' &&
          item.content &&
          item.content.length &&
          item.content[0].element === 'object' &&
          item.content[0].content
        ) {
          const name = classname(item)
          yield [classcode(name, item, options)]
        }
      }
    }
  }
}

// old-name/new-name map for renames for all the array objects to be List[MyType]
function* arrays(input, options) {
  for (const content of input.content) {
    if (!content.content) throw new Error('bad input')
    if (content.element === 'category') {
      for (const item of content.content) {
        if (
          item.element === 'dataStructure' &&
          item.content &&
          item.content.length &&
          item.content[0].element === 'array'
        ) {
          const name = classname(item)
          const tpe = item.content[0].content[0].element
          yield [name, `${options.themeCollectionType}[${tpe}]`]
        }
      }
    }
  }
}

exports.getConfig = function () {
  return {
    formats: ['1A'],
    options: [
      { //lookup as themeTrimname
        name: 'trimname',
        description: 'remove this string from all type names, ie: MyObjectSchema becoms MyObject',
        default: 'Schema'
      },
      { //lookup as themeCollectionType
        name: 'collection-type',
        description: 'scala type for collectoins. ie: List, Set, Array',
        default: 'List'
      },
      { //lookup as themeSuperClass
        name: 'super-class',
        description: 'case classes extend this abstract class',
        default: 'ApibCase'
      },
      { //lookup as themeDoubles
        name: 'doubles',
        description: 'a comma separated list of keys that should map to double instead of int',
        default: ''
      }
    ]
  }
}

exports.render = function (input, options, done) {

  //console.log(JSON.stringify(input, 0, 2))
  // prepend with abstract class
  const result = [
    `/**\n`,
    `   generated by aglio https://github.com/danielgtaylor/aglio with theme bluecase https://github.com/navicore/aglio-theme-bluecase\n`,
    `   with command:\n`,
    `       aglio -i ${options.input} -t ${options.theme} -o ${options.output} --theme-super-class ${options.themeSuperClass} --theme-collection-type ${options.themeCollectionType} --theme-doubles ${options.themeDoubles}\n`,
    `*/\n`,
    `\n`,
    `sealed abstract class ${options.themeSuperClass}\n`
  ]

  // generate case class text
  const code = classes(input, options)
  for (const [scala] of code) {
    result.push(`\n${scala}\n`)
  }

  // turn refs to array in apib into List[MyType]
  let resultStr = fixArrayReferences(result.join(''), input, options)
  
  // remove type suffixes from apip files
  var re1 = new RegExp(options.themeTrimname,'g')
  resultStr = resultStr.replace(re1, '') 
  
  done(null, resultStr)
}

